<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis | Welcome to my home!</title><meta name="author" content="EnyooXu"><meta name="copyright" content="EnyooXu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介Redis（REmote DIctionary Server），是一个开源的、高性能的内存数据库&#x2F;缓存&#x2F;消息中间件。 数据类型String简介在 Redis 的所有数据结构中，String（字符串） 是最基础、最底层，也是使用频率最高的一种。虽然它叫“String”，但它不仅能存储文本，还能存储整数、浮点数、甚至二进制数据（如图片或序列化后的对象）。 常用命令   命令 功">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/2026/01/21/study/Redis/index.html">
<meta property="og:site_name" content="Welcome to my home!">
<meta property="og:description" content="简介Redis（REmote DIctionary Server），是一个开源的、高性能的内存数据库&#x2F;缓存&#x2F;消息中间件。 数据类型String简介在 Redis 的所有数据结构中，String（字符串） 是最基础、最底层，也是使用频率最高的一种。虽然它叫“String”，但它不仅能存储文本，还能存储整数、浮点数、甚至二进制数据（如图片或序列化后的对象）。 常用命令   命令 功">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/study/redis_0.jpeg">
<meta property="article:published_time" content="2026-01-21T09:24:00.000Z">
<meta property="article:modified_time" content="2026-01-21T13:26:57.095Z">
<meta property="article:author" content="EnyooXu">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="中间件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/study/redis_0.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis",
  "url": "http://example.com/2026/01/21/study/Redis/",
  "image": "http://example.com/img/study/redis_0.jpeg",
  "datePublished": "2026-01-21T09:24:00.000Z",
  "dateModified": "2026-01-21T13:26:57.095Z",
  "author": [
    {
      "@type": "Person",
      "name": "EnyooXu",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2026/01/21/study/Redis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4-b1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><!-- hexo injector head_end start --><link rel="stylesheet" href="/css/categorybar.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 8.1.1"></head><body><div class="bg-animation" id="web_bg" style="background-image: url(/img/page.JPG);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><!-- 这里我希望在主页中每条文章都显示一个图片，但是我不希望在文章页面显示该图片--><!-- - top_img = page.top_img || page.cover || theme.default_top_img--><header class="post-bg" id="page-header" style="background: transparent;"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Welcome to my home!</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-21T09:24:00.000Z" title="发表于 2026-01-21 17:24:00">2026-01-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-21T13:26:57.095Z" title="更新于 2026-01-21 21:26:57">2026-01-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Redis（REmote DIctionary Server），是一个开源的、高性能的内存数据库&#x2F;缓存&#x2F;消息中间件。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>在 Redis 的所有数据结构中，String（字符串） 是最基础、最底层，也是使用频率最高的一种。虽然它叫“String”，但它不仅能存储文本，还能存储整数、浮点数、甚至二进制数据（如图片或序列化后的对象）。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SET key value [NX&#x2F;XX] [EX seconds] [PX milliseconds]</td>
<td>设置 key 的值，可带条件或过期时间</td>
<td><code>SET mykey &quot;Hello&quot; EX 10 NX</code></td>
<td>将 <code>mykey</code> 设置为 <code>&quot;Hello&quot;</code>，10 秒后过期，仅当 key 不存在时设置；<code>NX</code>&#x3D;仅不存在时设置，<code>XX</code>&#x3D;仅存在时设置，<code>EX</code>&#x3D;秒过期，<code>PX</code>&#x3D;毫秒过期</td>
</tr>
<tr>
<td>GET key</td>
<td>获取 key 的值</td>
<td><code>GET mykey</code></td>
<td>获取 <code>mykey</code> 的值，返回 <code>&quot;Hello&quot;</code></td>
</tr>
<tr>
<td>GETSET key value</td>
<td>设置新值并返回旧值</td>
<td><code>GETSET mykey &quot;World&quot;</code></td>
<td>将 <code>mykey</code> 的值改为 <code>&quot;World&quot;</code>，返回旧值 <code>&quot;Hello&quot;</code></td>
</tr>
<tr>
<td>MGET key1 key2 …</td>
<td>获取多个 key 的值</td>
<td><code>MGET mykey anotherkey</code></td>
<td>返回多个 key 的值，例如 <code>[&quot;World&quot;, &quot;value2&quot;]</code></td>
</tr>
<tr>
<td>SETNX key value</td>
<td>当 key 不存在时设置值</td>
<td><code>SETNX mykey &quot;Hello&quot;</code></td>
<td>仅当 <code>mykey</code> 不存在时才设置值，存在则不做修改，返回 1 成功，0 失败</td>
</tr>
<tr>
<td>SETEX key seconds value</td>
<td>设置值并指定过期时间（秒）</td>
<td><code>SETEX mykey 10 &quot;Hello&quot;</code></td>
<td>设置 <code>mykey</code> 为 <code>&quot;Hello&quot;</code> 并在 10 秒后过期</td>
</tr>
</tbody></table>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li>缓存 (Caching)<br>这是最普遍的用法。将复杂的数据库查询结果（通常序列化为 JSON 字符串）存入 Redis，并设置过期时间。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET user:1001 &#x27;&#123;&quot;name&quot;:&quot;张三&quot;, &quot;age&quot;:25&#125;&#x27; EX 3600</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>计数器 (Counter)<br>利用其原子性。例如：文章阅读量、微博转发数、视频点赞数。例如：有一个需求希望id能一直递增，例如1,2,3,4,5，当删除了id为5的数据后，希望下一次增加数据的id为6，这种情况下非常推荐使用该计数器。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR post:view:45672</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>分布式锁 (Distributed Lock)<br>利用 SET … NX 特性。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_order_123 &quot;process_id&quot; NX EX 10</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>限速器 (Rate Limiter)<br>例如限制某个 IP 每分钟只能访问 10 次，防止恶意刷接口。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">伪代码逻辑</span></span><br><span class="line">val = INCR ip:192.168.1.1</span><br><span class="line">IF val == 1 THEN EXPIRE ip:192.168.1.1 60</span><br><span class="line">IF val &gt; 10 THEN REJECT</span><br></pre></td></tr></table></figure>

<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Hash（哈希） 是一个 String 类型的 Field（字段） 和 Value（值） 的映射表。 如果你熟悉编程语言，可以把它类比为 Python 的<br>dict、Java的 HashMap 或者 PHP 的 Array。上文中String类型存的都是一个类型的数据，Hash可以理解为存的是一个JSON对象。redis可以直接操作这个JSON对象。</p>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>HSET key field value</td>
<td>设置哈希字段的值</td>
<td><code>HSET user:1 name &quot;Alice&quot;</code></td>
<td>将 <code>user:1</code> 的 <code>name</code> 字段设置为 <code>&quot;Alice&quot;</code></td>
</tr>
<tr>
<td>HGET key field</td>
<td>获取哈希字段的值</td>
<td><code>HGET user:1 name</code></td>
<td>获取 <code>user:1</code> 的 <code>name</code> 字段值，返回 <code>&quot;Alice&quot;</code></td>
</tr>
<tr>
<td>HMSET key field1 value1 field2 value2 …</td>
<td>设置多个哈希字段的值</td>
<td><code>HMSET user:1 age 25 city &quot;New York&quot;</code></td>
<td>同时设置多个字段，例如 <code>age</code> 为 25，<code>city</code> 为 <code>&quot;New York&quot;</code></td>
</tr>
<tr>
<td>HMGET key field1 field2 …</td>
<td>获取多个哈希字段的值</td>
<td><code>HMGET user:1 name age</code></td>
<td>获取多个字段的值，返回 <code>[&quot;Alice&quot;, &quot;25&quot;]</code></td>
</tr>
<tr>
<td>HGETALL key</td>
<td>获取哈希中所有字段和值</td>
<td><code>HGETALL user:1</code></td>
<td>获取整个哈希，返回 <code>[&quot;name&quot;, &quot;Alice&quot;, &quot;age&quot;, &quot;25&quot;, &quot;city&quot;, &quot;New York&quot;]</code></td>
</tr>
<tr>
<td>HDEL key field1 field2 …</td>
<td>删除一个或多个哈希字段</td>
<td><code>HDEL user:1 age city</code></td>
<td>删除指定字段，例如 <code>age</code> 和 <code>city</code></td>
</tr>
<tr>
<td>HEXISTS key field</td>
<td>判断哈希字段是否存在</td>
<td><code>HEXISTS user:1 name</code></td>
<td>如果字段存在返回 <code>1</code>，否则返回 <code>0</code></td>
</tr>
<tr>
<td>HKEYS key</td>
<td>获取哈希中所有字段</td>
<td><code>HKEYS user:1</code></td>
<td>返回哈希中所有字段名，例如 <code>[&quot;name&quot;]</code></td>
</tr>
<tr>
<td>HVALS key</td>
<td>获取哈希中所有值</td>
<td><code>HVALS user:1</code></td>
<td>返回哈希中所有字段值，例如 <code>[&quot;Alice&quot;]</code></td>
</tr>
<tr>
<td>HLEN key</td>
<td>获取哈希字段数量</td>
<td><code>HLEN user:1</code></td>
<td>返回field数量</td>
</tr>
</tbody></table>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><ol>
<li>存储对象数据<br>如购物车信息（Key 为用户 ID，Field 为商品 ID，Value 为商品数量、用户信息、配置信息。</li>
<li>聚合数据统计<br>比如统计一篇文章的多个指标（阅读数、点赞数、收藏数），可以全部放在一个 Hash Key 下，方便统一管理。</li>
</ol>
<h3 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h3><p>Hash数据类型的底层存储并不是一成不变的，而是会根据数据规模和配置在<code>ziplist / listpack</code> 和 <code>hashtable</code>两种编码之间自动切换，这是<br>Redis 非常经典的一种“节省内存的设计”。</p>
<ul>
<li>ziplist &#x2F; listpack：当Hash中的字段数量较少，每个 field 和 value 的长度较短时会使用该种结构，这种结构本质就是一块连续的内存，没有指针，非常节省内存。在Redis<br>3.x ~ 5.x会使用 ziplist，在Redis 6.0+：改为 listpack（ziplist 的升级版）。</li>
<li>hashtable：当Hash中字段大于512或者任一 field 或 value 长度 &gt; 64 字节时就会转成hashtable结构，他的底层是Redis 自己实现的<br>dict，基于数组 + 链表的结构，查询速度基本为o(1)，但是同时有指针带来的开销，会增加内存的使用空间。</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>Redis 的 List 是一个“有序、可重复、两端高效操作”的链表结构，底层从 ziplist&#x2F;listpack 进化为<br>quicklist。可以将它理解为Java中的Deque这种数据结构。</p>
<h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LPUSH key value1 value2 …</td>
<td>将一个或多个值插入列表头部</td>
<td><code>LPUSH mylist a b c</code></td>
<td>按顺序插入头部，最终列表为 <code>[&quot;c&quot;,&quot;b&quot;,&quot;a&quot;]</code></td>
</tr>
<tr>
<td>RPUSH key value1 value2 …</td>
<td>将一个或多个值插入列表尾部</td>
<td><code>RPUSH mylist a b c</code></td>
<td>按顺序插入尾部，最终列表为 <code>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code></td>
</tr>
<tr>
<td>LPOP key</td>
<td>移除并获取列表的第一个元素</td>
<td><code>LPOP mylist</code></td>
<td>移除并返回列表头部的元素</td>
</tr>
<tr>
<td>RPOP key</td>
<td>移除并获取列表的最后一个元素</td>
<td><code>RPOP mylist</code></td>
<td>移除并返回列表尾部的元素</td>
</tr>
<tr>
<td>LLEN key</td>
<td>获取列表长度</td>
<td><code>LLEN mylist</code></td>
<td>返回列表中元素的数量</td>
</tr>
<tr>
<td>LRANGE key start end</td>
<td>获取列表中指定范围的元素</td>
<td><code>LRANGE mylist 0 -1</code></td>
<td>获取整个列表，返回 <code>[&quot;c&quot;,&quot;b&quot;,&quot;a&quot;]</code></td>
</tr>
<tr>
<td>LLEN key</td>
<td>获取列表的长度</td>
<td><code>LLEN mylist</code></td>
<td>返回 <code>3</code>（列表中元素个数）</td>
</tr>
<tr>
<td>LINDEX key index</td>
<td>根据下标获取列表中的元素</td>
<td><code>LINDEX mylist 1</code></td>
<td>返回 <code>&quot;b&quot;</code>（索引从 0 开始）</td>
</tr>
<tr>
<td>LSET key index value</td>
<td>修改列表指定下标位置的值</td>
<td><code>LSET mylist 1 &quot;x&quot;</code></td>
<td>将索引 1 的元素修改为 <code>&quot;x&quot;</code>，列表变为 <code>[&quot;c&quot;,&quot;x&quot;,&quot;a&quot;]</code></td>
</tr>
<tr>
<td>LTRIM key start end</td>
<td>按指定区间裁剪列表</td>
<td><code>LTRIM mylist 0 1</code></td>
<td>只保留索引 0 和 1 的元素，列表变为 <code>[&quot;c&quot;,&quot;x&quot;]</code></td>
</tr>
</tbody></table>
<h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><ol>
<li>消息队列 &#x2F; 任务队列<br>生产者将任务<code>LPUSH</code>到列表头部，消费者用<code>RPOP</code>或<code>BRPOP</code>弹出执行。一般在异步任务处理、日志收集、消息通知等方面可以使用。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPUSH task_queue &quot;task1&quot;</span><br><span class="line">LPUSH task_queue &quot;task2&quot;</span><br><span class="line">RPOP task_queue</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>最近访问 &#x2F; 历史记录<br>使用列表头部插入新元素，限制长度 LTRIM。适用于浏览历史、聊天记录、操作日志。只保留最新的 N 条数据。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPUSH user:123:recent_views &quot;item42&quot;</span><br><span class="line">LTRIM user:123:recent_views 0 9  # 只保留最近10条</span><br><span class="line">LRANGE user:123:recent_views 0 -1</span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>Set 是一种 无序、不重复元素集合，可以把它想象成数学中的集合，操作元素很高效，并且可以快速做集合运算。</p>
<h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
<th>示例</th>
<th>效果说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>SADD key member [member …]</code></td>
<td>添加一个或多个元素到集合</td>
<td><code>SADD myset a b c</code></td>
<td>集合 <code>myset</code> 中增加元素 a、b、c，重复元素会被忽略</td>
</tr>
<tr>
<td><code>SREM key member [member …]</code></td>
<td>从集合中删除一个或多个元素</td>
<td><code>SREM myset b</code></td>
<td>删除集合 <code>myset</code> 中的元素 b</td>
</tr>
<tr>
<td><code>SISMEMBER key member</code></td>
<td>判断元素是否在集合中</td>
<td><code>SISMEMBER myset a</code></td>
<td>返回 1 表示元素 a 存在，0 表示不存在</td>
</tr>
<tr>
<td><code>SCARD key</code></td>
<td>获取集合元素数量</td>
<td><code>SCARD myset</code></td>
<td>返回集合 <code>myset</code> 的元素个数</td>
</tr>
<tr>
<td><code>SMEMBERS key</code></td>
<td>获取集合中的所有元素</td>
<td><code>SMEMBERS myset</code></td>
<td>返回集合 <code>myset</code> 的所有元素，如 <code>[&quot;a&quot;,&quot;c&quot;]</code></td>
</tr>
<tr>
<td><code>SRANDMEMBER key [count]</code></td>
<td>随机返回一个或多个元素</td>
<td><code>SRANDMEMBER myset 2</code></td>
<td>随机返回集合中的 2 个元素，不删除</td>
</tr>
<tr>
<td><code>SPOP key [count]</code></td>
<td>随机弹出一个或多个元素</td>
<td><code>SPOP myset 1</code></td>
<td>随机弹出集合中 1 个元素，元素会被删除</td>
</tr>
<tr>
<td><code>SMOVE source dest member</code></td>
<td>将元素从一个集合移动到另一个集合</td>
<td><code>SMOVE myset otherset a</code></td>
<td>将元素 a 从 <code>myset</code> 移到 <code>otherset</code></td>
</tr>
<tr>
<td><code>SINTER key [key …]</code></td>
<td>求多个集合的交集</td>
<td><code>SINTER set1 set2</code></td>
<td>返回集合 set1 和 set2 的公共元素</td>
</tr>
<tr>
<td><code>SUNION key [key …]</code></td>
<td>求多个集合的并集</td>
<td><code>SUNION set1 set2</code></td>
<td>返回集合 set1 和 set2 的所有元素去重</td>
</tr>
<tr>
<td><code>SDIFF key [key …]</code></td>
<td>求集合差集</td>
<td><code>SDIFF set1 set2</code></td>
<td>返回在 set1 但不在 set2 的元素</td>
</tr>
<tr>
<td><code>SINTERSTORE dest key [key …]</code></td>
<td>求交集并存入新集合</td>
<td><code>SINTERSTORE newset set1 set2</code></td>
<td>将 set1 与 set2 的交集存入 <code>newset</code></td>
</tr>
<tr>
<td><code>SUNIONSTORE dest key [key …]</code></td>
<td>求并集并存入新集合</td>
<td><code>SUNIONSTORE newset set1 set2</code></td>
<td>将 set1 与 set2 的并集存入 <code>newset</code></td>
</tr>
<tr>
<td><code>SDIFFSTORE dest key [key …]</code></td>
<td>求差集并存入新集合</td>
<td><code>SDIFFSTORE newset set1 set2</code></td>
<td>将 set1 与 set2 的差集存入 <code>newset</code></td>
</tr>
</tbody></table>
<h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><ol>
<li>存储的值需要唯一<br>因为set自动会进行去重，所以可以用来做存储唯一的用户 ID、IP、手机号等。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SADD user_ids 123</span><br><span class="line">SADD user_ids 123  # 不会重复</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>用来做社交关系<br>比如说用set来存储用户关注，当需要查询共同好友，互粉等情况时，可以使用set来实现。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTER user:alice:friends user:bob:friends</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>抽奖的实现<br>因为set是无序的，所以每次从set中抽出的值都是随机的，可以用来模拟抽奖。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRANDMEMBER prizes 3</span><br></pre></td></tr></table></figure>

<h3 id="存储原理-1"><a href="#存储原理-1" class="headerlink" title="存储原理"></a>存储原理</h3><p>set底层是有两种数据结构的分别是intset和hashtable，底层小集合用 intset 压缩存储，大集合用哈希表，高效支持查找、添加、删除和集合运算，同时自动根据元素类型和数量切换存储策略。</p>
<ul>
<li>当集合元素全是整数且数量较少时会使用intset，他是一块连续的内存数组，占用内存较小，查询效率极高。</li>
<li>当添加非整数或者元素数量超阈值（默认512），Redis 会自动转换为 Hash Table。底层使用<br>dict（哈希表）存储，只使用哈希表的key，value通常默认都是为null来保证元素的唯一性，查找、添加、删除都非常快，但是他会占用更多的内存空间。</li>
</ul>
<h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>ZSet是一种 有序、唯一元素集合，其中每一个元素都有一个分数，并按照元素按照分数升序排序，分数可以相同，但是元素不可以重复。</p>
<h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
<th>示例</th>
<th>效果说明</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>ZADD key score member [score member …]</code></td>
<td>添加一个或多个元素到有序集合，若元素存在则更新 score</td>
<td><code>ZADD myzset 1 a 2 b</code></td>
<td>将元素 a（score&#x3D;1）和 b（score&#x3D;2）添加到 myzset，如果已存在则更新分数</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ZREM key member [member …]</code></td>
<td>从有序集合中删除一个或多个元素</td>
<td><code>ZREM myzset a</code></td>
<td>删除 myzset 中的元素 a</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ZSCORE key member</code></td>
<td>获取元素的 score 值</td>
<td><code>ZSCORE myzset a</code></td>
<td>返回元素 a 的 score 值，例如 1.0</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ZRANK key member</code></td>
<td>获取元素按 score 升序的排名</td>
<td><code>ZRANK myzset b</code></td>
<td>返回元素 b 的排名（0 为最小 score），不存在返回 nil</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ZREVRANK key member</code></td>
<td>获取元素按 score 降序的排名</td>
<td><code>ZREVRANK myzset b</code></td>
<td>返回元素 b 的降序排名</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ZRANGE key start stop [WITHSCORES]</code></td>
<td>按排名范围返回元素，可选返回 score</td>
<td><code>ZRANGE myzset 0 1 WITHSCORES</code></td>
<td>返回排名第 0 和 1 的元素及 score，例如 <code>[(&quot;a&quot;,1),(&quot;b&quot;,2)]</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ZREVRANGE key start stop [WITHSCORES]</code></td>
<td>按排名逆序返回元素，可选返回 score</td>
<td><code>ZREVRANGE myzset 0 1 WITHSCORES</code></td>
<td>返回最高 score 前两个元素及 score</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ZRANGEBYSCORE key min max [WITHSCORES]</code></td>
<td>按 score 范围返回元素</td>
<td><code>ZRANGEBYSCORE myzset 1 2 WITHSCORES</code></td>
<td>返回 score 在 1~2 范围的元素及 score</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ZREVRANGEBYSCORE key max min [WITHSCORES]</code></td>
<td>按 score 范围逆序返回元素</td>
<td><code>ZREVRANGEBYSCORE myzset 2 1 WITHSCORES</code></td>
<td>返回 score 在 2~1 范围的元素及 score（降序）</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ZCOUNT key min max</code></td>
<td>统计 score 在指定范围的元素数量</td>
<td><code>ZCOUNT myzset 1 2</code></td>
<td>返回 score 在 1~2 的元素数量</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ZCARD key</code></td>
<td>获取有序集合中元素数量</td>
<td><code>ZCARD myzset</code></td>
<td>返回 myzset 中元素总数</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ZINCRBY key increment member</code></td>
<td>给元素的 score 增加指定值</td>
<td><code>ZINCRBY myzset 2 a</code></td>
<td>元素 a 的 score 增加 2，如果不存在则添加 a 并设置 score&#x3D;2</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ZPOPMIN key [count]</code></td>
<td>弹出 score 最小的元素，可指定数量</td>
<td><code>ZPOPMIN myzset 1</code></td>
<td>返回并删除 score 最小的元素</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ZPOPMAX key [count]</code></td>
<td>弹出 score 最大的元素，可指定数量</td>
<td><code>ZPOPMAX myzset 1</code></td>
<td>返回并删除 score 最大的元素</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ZREM RANGE BY RANK key start stop</code></td>
<td>按排名范围删除元素</td>
<td><code>ZREMRANGEBYRANK myzset 0 1</code></td>
<td>删除排名第 0 和 1 的元素</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ZREM RANGE BY SCORE key min max</code></td>
<td>按 score 范围删除元素</td>
<td><code>ZREMRANGEBYSCORE myzset 1 2</code></td>
<td>删除 score 在 1~2 范围的元素</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h3><ol>
<li>排行榜 &#x2F; 积分榜<br>可以拿key当做用户id，value来存储用户的游戏积分，并按照积分来进行排序。其他排行榜也是类似使用。</li>
<li>带去重的延迟队列<br>一般情况下使用list就可以完成延迟队列，但是如果需要实现去重就可以使用zset数据结构。</li>
</ol>
<h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><p>用于存储地理坐标（经度、纬度）并支持各种地理空间的计算如： 距离计算、 范围搜索、 最近点查询、 按距离排序；</p>
<h3 id="常用命令-5"><a href="#常用命令-5" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
<th>示例</th>
<th>执行效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>GEOADD key longitude latitude member [longitude latitude member ...]</code></td>
<td>添加地理位置坐标到指定 key</td>
<td><code>GEOADD locations 116.397128 39.916527 &quot;Beijing&quot;</code></td>
<td>将 <code>&quot;Beijing&quot;</code> 的经纬度坐标加入 <code>locations</code></td>
</tr>
<tr>
<td><code>GEOPOS key member [member ...]</code></td>
<td>获取一个或多个成员的经纬度</td>
<td><code>GEOPOS locations &quot;Beijing&quot;</code></td>
<td>返回 <code>[116.397128, 39.916527]</code></td>
</tr>
<tr>
<td><code>GEODIST key member1 member2 [unit]</code></td>
<td>计算两个成员之间的距离</td>
<td><code>GEODIST locations &quot;Beijing&quot; &quot;Shanghai&quot; km</code></td>
<td>返回北京到上海的距离（单位 km）</td>
</tr>
<tr>
<td><code>GEOHASH key member [member ...]</code></td>
<td>返回成员的 geohash 值</td>
<td><code>GEOHASH locations &quot;Beijing&quot;</code></td>
<td>返回 <code>&quot;wx4g0c0&quot;</code> 形式的 geohash 编码</td>
</tr>
</tbody></table>
<h3 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h3><ol>
<li>附近的人 &#x2F; 商家 &#x2F; 车辆<br>比如说打车软件中的“查找用户周围 1km<br>内的出租车”等。注意着点和neo4j的功能不同，neo4j更加侧重于最优路径的计算。以物流运输成本为例：因为在一个实际运输项目中还有包含运费过路费等其他复杂情况，有时候不一定距离最短的情况下成本是最低的，neo4j更擅长这种计算。</li>
</ol>
<p>除了上述的这些数据结构以外，redis还有很多其他类型的数据结构，但是使用频率一般情况下来说不是很高，有需要可以再了解。</p>
<h1 id="通用指令"><a href="#通用指令" class="headerlink" title="通用指令"></a>通用指令</h1><table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
<th>示例</th>
<th>效果说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>DEL key [key …]</code></td>
<td>删除一个或多个键</td>
<td><code>DEL mykey</code></td>
<td>删除键 mykey，如果不存在则忽略</td>
</tr>
<tr>
<td><code>EXISTS key [key …]</code></td>
<td>判断一个或多个键是否存在</td>
<td><code>EXISTS mykey</code></td>
<td>返回 1 表示存在，0 表示不存在</td>
</tr>
<tr>
<td><code>EXPIRE key seconds</code></td>
<td>设置键的过期时间（秒）</td>
<td><code>EXPIRE mykey 60</code></td>
<td>mykey 在 60 秒后自动删除</td>
</tr>
<tr>
<td><code>PEXPIRE key milliseconds</code></td>
<td>设置键的过期时间（毫秒）</td>
<td><code>PEXPIRE mykey 1500</code></td>
<td>mykey 在 1.5 秒后自动删除</td>
</tr>
<tr>
<td><code>TTL key</code></td>
<td>查看键的剩余生存时间（秒）</td>
<td><code>TTL mykey</code></td>
<td>返回 mykey 的剩余生存时间，-1 表示永久，-2 表示不存在</td>
</tr>
<tr>
<td><code>PTTL key</code></td>
<td>查看键的剩余生存时间（毫秒）</td>
<td><code>PTTL mykey</code></td>
<td>返回 mykey 的剩余毫秒数</td>
</tr>
<tr>
<td><code>PERSIST key</code></td>
<td>移除键的过期时间，使其永久存在</td>
<td><code>PERSIST mykey</code></td>
<td>mykey 成为永久键，不再过期</td>
</tr>
<tr>
<td><code>RENAME key newkey</code></td>
<td>重命名键</td>
<td><code>RENAME mykey newkey</code></td>
<td>将 mykey 重命名为 newkey，如果 newkey 存在会覆盖</td>
</tr>
<tr>
<td><code>RENAMENX key newkey</code></td>
<td>仅当 newkey 不存在时重命名</td>
<td><code>RENAMENX mykey newkey</code></td>
<td>返回 1 表示成功重命名，0 表示 newkey 已存在</td>
</tr>
<tr>
<td><code>TYPE key</code></td>
<td>查看键的数据类型</td>
<td><code>TYPE mykey</code></td>
<td>返回 mykey 的类型，如 string、list、set、zset、hash</td>
</tr>
<tr>
<td><code>KEYS pattern</code></td>
<td>查找符合模式的键</td>
<td><code>KEYS user*</code></td>
<td>返回所有以 user 开头的键（不推荐生产环境大量使用）</td>
</tr>
<tr>
<td><code>SCAN cursor [MATCH pattern] [COUNT count]</code></td>
<td>增量迭代扫描键</td>
<td><code>SCAN 0 MATCH user* COUNT 10</code></td>
<td>返回部分符合模式的键，支持分页迭代，安全生产使用</td>
</tr>
<tr>
<td><code>TTL key</code></td>
<td>获取键的剩余时间（秒）</td>
<td><code>TTL mykey</code></td>
<td>查看 mykey 剩余秒数，-1 表示永久，-2 表示不存在</td>
</tr>
<tr>
<td><code>DUMP key</code></td>
<td>序列化键的值为二进制字符串</td>
<td><code>DUMP mykey</code></td>
<td>返回 mykey 的序列化二进制，可以用于迁移或备份</td>
</tr>
<tr>
<td><code>RESTORE key ttl serialized-value</code></td>
<td>恢复序列化的键值</td>
<td><code>RESTORE mykey 0 &quot;\x00...&quot;</code></td>
<td>将序列化数据恢复成键 mykey</td>
</tr>
<tr>
<td><code>EXISTS key</code></td>
<td>判断键是否存在</td>
<td><code>EXISTS mykey</code></td>
<td>返回 1 表示存在，0 表示不存在</td>
</tr>
<tr>
<td><code>OBJECT subcommand key</code></td>
<td>查看键的内部信息</td>
<td><code>OBJECT REFCOUNT mykey</code></td>
<td>查看键的引用计数、编码方式等（调试用）</td>
</tr>
<tr>
<td><code>MOVE key db</code></td>
<td>将键移动到指定数据库</td>
<td><code>MOVE mykey 1</code></td>
<td>将 mykey 移到 Redis 的 db1，如果目标 db 有同名键返回 0</td>
</tr>
<tr>
<td><code>FLUSHDB</code></td>
<td>删除当前数据库的所有键</td>
<td><code>FLUSHDB</code></td>
<td>当前数据库全部清空</td>
</tr>
<tr>
<td><code>FLUSHALL</code></td>
<td>删除所有数据库的所有键</td>
<td><code>FLUSHALL</code></td>
<td>Redis 实例中所有键全部清空</td>
</tr>
<tr>
<td><code>PERSIST key</code></td>
<td>移除键的过期时间</td>
<td><code>PERSIST mykey</code></td>
<td>使 mykey 永久存在</td>
</tr>
<tr>
<td><code>RENAME key newkey</code></td>
<td>重命名键</td>
<td><code>RENAME mykey newkey</code></td>
<td>将 mykey 改名为 newkey</td>
</tr>
</tbody></table>
<h1 id="Redis问题"><a href="#Redis问题" class="headerlink" title="Redis问题"></a>Redis问题</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><p>缓存雪崩（Cache Avalanche）是指在极短时间内，大量的缓存同时失效，或者 Redis 插件宕机，导致原本应该访问缓存的请求全部涌向数据库，造成数据库压力剧增甚至崩溃的现象。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="大量-Key-同时过期"><a href="#大量-Key-同时过期" class="headerlink" title="大量 Key 同时过期"></a>大量 Key 同时过期</h4><p>这是最常见的雪崩诱因，通常是因为批量写入数据时设置了相同的过期时间。</p>
<ul>
<li>设置随机过期时间： 在原有的过期时间基础上，加上一个随机值（例如 1-5 分钟的随机偏差）。这样可以分散 Key 的失效时间点，避免集体过期。</li>
<li>设置热点数据永不过期： 对于一些极高频访问的业务数据，不设置过期时间，而是由后台逻辑在数据更新时主动去同步或更新缓存。</li>
<li>逻辑过期： 在缓存的 Value 中包含一个“过期时间”字段。查询时发现逻辑时间已过期，则通过中间件或异步线程去更新缓存，而当前请求先返回旧数据，实现“准实时”且“高可用”。</li>
</ul>
<h4 id="Redis-宕机-不可用"><a href="#Redis-宕机-不可用" class="headerlink" title="Redis 宕机&#x2F;不可用"></a>Redis 宕机&#x2F;不可用</h4><p>如果雪崩是因为 Redis 服务本身挂了，就需要在架构层面进行加固。</p>
<ul>
<li>构建 Redis 高可用集群： 使用 Redis Sentinel（哨兵模式） 或 Redis Cluster（集群模式）。当主节点宕机时，系统能自动进行故障转移，实现秒级切换。</li>
<li>多级缓存架构： 使用 本地缓存（如 Guava Cache、Caffeine） + 远程分布式缓存（Redis）。 即使 Redis 挂了，本地缓存还能扛住一部分流量，为数据库争取缓冲时间。</li>
</ul>
<h4 id="数据库层级的保护"><a href="#数据库层级的保护" class="headerlink" title="数据库层级的保护"></a>数据库层级的保护</h4><p>当缓存已经失效，流量已经冲向数据库时，就需要在数据库层最后一层防线。</p>
<ul>
<li>服务熔断与限流： 使用 Sentinel 或 Hystrix 等组件。一旦检测到数据库压力过大或响应变慢，直接启动熔断机制，暂停非核心业务的访问，并进行请求降级（返回默认值或错误页面），保护数据库不被冲垮。</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><p>缓存击穿是指某一个极其热点的 Key 在过期的瞬间，有海量的并发请求同时涌入。由于缓存失效，这些请求会同时冲向数据库，可能导致数据库瞬间瘫痪。</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="互斥锁-redis分布式锁"><a href="#互斥锁-redis分布式锁" class="headerlink" title="互斥锁(redis分布式锁)"></a>互斥锁(redis分布式锁)</h4><p>这是最常用的方案。当缓存失效时，不立即去查询数据库，而是先尝试获取一个互斥锁（如 Redis 的<br>setnx），只有获得锁的那个线程能去查询数据库并回写缓存，其他线程则不断重试或等待。这样当获得锁的线程查询数据库以后会将值重新放到缓存中，并将锁释放。当其他线程发现获取锁后会第一时间再次查询redis中的数据，发现此时已经有数据了就直接返回，没有的话重复第一个线程的动作。这种方法通常用在订单，金融方面等对数据的准确性要求较高的地方使用。下面举一个使用Redisson实现分布式锁的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 先从缓存中获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 缓存命中则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 缓存缺失，准备获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span> + key;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * tryLock 参数说明：</span></span><br><span class="line"><span class="comment">             * waitTime:  等待锁的时间（10秒），超过则放弃</span></span><br><span class="line"><span class="comment">             * leaseTime: 锁的自动释放时间（30秒），防止宕机死锁</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (lock.tryLock(<span class="number">10</span>, <span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 4. 【关键】获取锁后，再次检查缓存（Double Check）</span></span><br><span class="line">                    <span class="comment">// 理由：高并发下，第一个线程写完缓存释放锁后，后续线程进锁时不应再查库</span></span><br><span class="line">                    value = redisTemplate.opsForValue().get(key);</span><br><span class="line">                    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> value;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 5. 查询数据库</span></span><br><span class="line">                    value = queryDatabase(key);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 6. 回写缓存，并设置随机过期时间防止雪崩</span></span><br><span class="line">                    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">expireTime</span> <span class="operator">=</span> <span class="number">30</span> + (<span class="type">int</span>) (Math.random() * <span class="number">10</span>); <span class="comment">// 30-40min</span></span><br><span class="line">                        redisTemplate.opsForValue().set(key, value, expireTime, TimeUnit.MINUTES);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 7. 释放锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 8. 获取不到锁的线程，休眠后重试（或返回降级结果）</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">return</span> getData(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 或者抛出业务异常</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">queryDatabase</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟数据库查询</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DataFromDB_for_&quot;</span> + key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h4><p>这种方案不再给 Redis 的 Key 设置真实的过期时间（TTL），而是把过期时间存放在 Value 字段中。</p>
<ol>
<li>查询缓存，取出数据后判断其中的“逻辑过期时间”。</li>
<li>如果已过期，开启一个异步线程去查询数据库并更新缓存。</li>
<li>在异步更新完成前，当前请求（以及其他并发请求）直接返回旧数据。</li>
</ol>
<p>这种做法的性能极高，不存在线程阻塞等待，用户体验好，但是会存在数据不一致的情况（用户会拿到旧数据），且会增加代码的复杂度。</p>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul>
<li>热点数据预热： 在秒杀活动或高峰期开始前，提前将热点 Key 写入缓存，并手动延长其有效期。</li>
<li>永久不过期： 对于流量极大的静态配置类数据，直接设置为永久有效，通过后台管理系统手动触发更新。</li>
<li></li>
</ul>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h3><p>缓存穿透指查询一个根本不存在的数据。由于缓存中没有（肯定没中），数据库中也没有（查询结果为空），导致每次请求都要去数据库查询。如果有攻击者伪造大量不存在的<br>Key 进行恶意攻击，数据库会因承受不住压力而瘫痪。</p>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h4><p>当数据库返回空结果时，我们也把这个“空值”（如 null 或特定的默认值）写入缓存，并设置一个较短的过期时间（例如 1-5<br>分钟）。这种方法实现简单且维护方便，但是如果查询redis中的key是随机生成的会消耗Redis<br>大量内存来存储这些空数据。通过可能会导致短期的数据不一致(如果之后数据库真的插入了这个 Key 的数据)。</p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>在请求进入缓存层之前，先经过一层布隆过滤器。布隆过滤器由一个很长的二进制向量（位图）和一系列哈希函数组成。它能告诉你：“这个<br>Key 可能存在”或“这个 Key 绝对不存在”。 如果布隆过滤器说不存在，直接拦截请求并返回。 如果布隆过滤器说可能存在，才去访问 Redis<br>和数据库。布隆过滤器占用的内存很小而且能有效拦截大部分的非法请求，但是通过也是存在误判的可能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getDataWithBloom</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取布隆过滤器</span></span><br><span class="line">    RBloomFilter&lt;String&gt; bloomFilter = redissonClient.getBloomFilter(<span class="string">&quot;user_filter&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 如果布隆过滤器判断绝对不存在，直接拦截</span></span><br><span class="line">    <span class="keyword">if</span> (!bloomFilter.contains(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 后续走正常的 Redis -&gt; DB 逻辑</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        value = db.query(key);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 配合“缓存空值”方案，双重保险</span></span><br><span class="line">            redis.set(key, <span class="string">&quot;&quot;</span>, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redis.set(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他方法-1"><a href="#其他方法-1" class="headerlink" title="其他方法"></a>其他方法</h4><p>在请求接受的源头处做一定的过滤，比如说ID的长度为8，那么当请求来的时候可知直接在Controller层拦截掉，这种方法能过滤掉大部分低级的、无脑的恶意攻击。</p>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h2><p>Redis 的持久化主要为了解决一个问题：Redis 数据存储在内存中，一旦服务器宕机或重启，内存中的数据就会丢失。</p>
<h2 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>RDB的核心思想是<strong>定时拍快照</strong>：在指定的时间间隔内，将内存中当前时刻的全量数据生成一个二进制文件（通常命名为<br>dump.rdb）保存到磁盘上。在生产环境中，Redis 几乎总是使用<code>bgsave</code>命令来进行异步持久化，其过程如下：</p>
<ol>
<li>执行命令：主进程接收到持久化请求（手动或自动触发）。</li>
<li>创建子进程：主进程调用系统的 fork() 函数创建一个子进程。</li>
<li>写快照：子进程将当前内存中的数据写入一个临时的 RDB 文件。</li>
<li>替换原文件：写入完成后，用临时文件替换旧的 dump.rdb 文件。</li>
</ol>
<p>写时复制：在子进程写快照期间，主进程仍然可以处理写请求。如果主进程修改了某块内存数据，操作系统会为这块数据创建一个副本，主进程在副本上修改，而子进程继续读取原始内存数据进行备份。这样既保证了数据一致性，又不阻塞主进程。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ul>
<li>恢复速度极快：RDB 文件是压缩后的紧凑二进制数据，加载速度远快于AOF。</li>
<li>性能最大化：持久化由子进程处理，主进程不需要进行任何磁盘 IO 操作。</li>
<li>适合冷备：可以通过备份 dump.rdb 文件（如每天备份一次到云存储），实现异地备份。</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据安全性低：RDB的致命伤。因为是间隔触发，如果 Redis 在两次快照之间崩溃，这期间的数据会全部丢失。</li>
<li>资源损耗：如果内存数据量极大（比如 10GB 以上），fork 子进程的过程可能导致服务器出现明显的秒级停顿。</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><p>AOF 的核心思想是Redis 会将每一个写命令（如 SET、DEL、SADD 等）通过 write 函数追加到 AOF 文件的末尾。当 Redis<br>重启时，会通过重新执行这些命令来在内存中重建整个数据集。AOF 持久化并不是直接写磁盘，而是经过了几个步骤：</p>
<ol>
<li>命令追加：写命令被追加到服务器系统的 AOF 缓冲区（aof_buf）。</li>
<li>文件写入与同步：根据设置的策略，将缓冲区内容写入磁盘。</li>
<li>文件重写：随着文件变大，定期压缩 AOF 文件。</li>
</ol>
<h4 id="保存策略"><a href="#保存策略" class="headerlink" title="保存策略"></a>保存策略</h4><table>
<thead>
<tr>
<th>策略名称</th>
<th>原理说明</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Always</td>
<td>每个写命令执行完，立即同步将日志写回磁盘</td>
<td>数据最安全，理论上不丢数据</td>
<td>性能极差，磁盘 IO 开销巨大</td>
</tr>
<tr>
<td>Everysec</td>
<td>每个写命令执行完先写入缓冲区，每隔 1 秒将缓冲区内容同步到磁盘</td>
<td>性能与安全平衡（推荐）</td>
<td>宕机时可能丢失 1 秒的数据</td>
</tr>
<tr>
<td>No</td>
<td>写命令写入缓冲区后，由操作系统决定何时同步到磁盘</td>
<td>性能最好</td>
<td>宕机时丢失数据量不可控</td>
</tr>
</tbody></table>
<h4 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h4><ul>
<li>由于 AOF 是追加写，文件会越来越大（例如你对一个 Key 执行了 100 次 INCR，AOF 会记录 100 条命令）。为了解决这个问题，Redis 引入了<br>重写机制。Redis 并不需要读取旧的 AOF 文件，而是直接读取内存中的当前数据。它会生成能达到当前数据状态的最少命令。 比如：内存中<br>count 的值是 100。重写前 AOF 有 100 条 INCR；重写后，新 AOF 只有一条 SET count 100。</li>
<li>触发重写机制的条件：<strong>比上次重写后的大小翻倍时</strong>且<strong>文件至少要达到 64MB</strong>。例如：上一次AOF后的文件大小为50M，那么下一次触发重写的时机为<br>50M * 2 &#x3D; 100M的时候才会触发。</li>
</ul>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ol>
<li>数据更可靠：默认的 everysec 策略下，最多只丢 1 秒数据。</li>
<li>日志易读、可修复：AOF 记录的是原始 Redis 命令。如果由于某些原因（磁盘满等）导致末尾指令写破损，可以使用 redis-check-aof<br>工具轻松修复。</li>
<li>支持“误操作”恢复：如果你不小心执行了 FLUSHALL 命令清空了数据库，只要 AOF 还没被重写，你可以立即停止服务，删掉 AOF 末尾的那条<br>FLUSHALL 指令，重启后数据就全回来了。</li>
</ol>
<p>缺点：</p>
<ol>
<li>文件体积大：通常比相同数据集的 RDB 文件大得多。</li>
<li>恢复速度慢：重启时需要“跑一遍脚本”，如果命令千万级，恢复时间会很久。</li>
<li>性能压力：虽然是追加写，但在高并发下，频繁的磁盘 IO 还是会比 RDB 略慢。</li>
</ol>
<h3 id="混合模式（RDB-AOF）"><a href="#混合模式（RDB-AOF）" class="headerlink" title="混合模式（RDB + AOF）"></a>混合模式（RDB + AOF）</h3><h4 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li>持久化过程<br>混合持久化（RDB + AOF）是 Redis 目前最推荐的持久化方案。它的核心逻辑是：利用 RDB 的快速恢复能力，结合 AOF 的数据实时性。<br>在混合使用模式下，AOF 文件的结构会发生变化：它的前半部分是 二进制的 RDB 格式，后半部分是 文本格式的 AOF<br>命令。混合持久化并不是在每一次写命令时发生的，而是在 AOF 重写（Rewrite） 的时候发生的：</li>
</ul>
<ol>
<li>触发重写：当 AOF 文件体积达到阈值时，Redis 触发后台 AOF 重写。</li>
<li>创建快照：Redis 会将当前的内存数据以 RDB 二进制 的格式写入新的 AOF 文件开头。</li>
<li>记录增量：在创建快照期间，主进程收到的写命令会继续以 AOF 文本 格式追加到这个新文件的末尾。</li>
<li>替换文件：重写完成后，用这个“混合型”文件替换旧的纯文本 AOF 文件。</li>
</ol>
<ul>
<li>数据恢复<br>当重启 Redis 服务时：</li>
</ul>
<ol>
<li>识别格式：Redis 首先加载 AOF 文件。</li>
<li>快速加载：发现开头是 RDB 格式，直接将二进制数据极速载入内存（这省去了大量命令回放的时间）。</li>
<li>增量重放：加载完 RDB 部分后，继续读取并执行文件末尾的 AOF 命令，恢复重写期间的数据。</li>
</ol>
<h1 id="Redis主从"><a href="#Redis主从" class="headerlink" title="Redis主从"></a>Redis主从</h1><h2 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h2><p>主从复制是 Redis 高可用的基石。它的核心思想是将一台 Redis 服务器（Master，主节点）的数据，实时同步到其他 Redis<br>服务器（Slave&#x2F;Replica，从节点）。 在主从架构中，数据的流动是单向的：只能从主节点流向从节点。使用主从结构主要原因有以下几点：</p>
<ol>
<li>读写分离：主节点负责写操作，从节点负责读操作。由于大多数互联网场景都是“读多写少”，这能极大地提高系统的吞吐量。</li>
<li>数据冗余：实现了数据的热备份，是持久化之外的另一种可靠数据保护方式。</li>
<li>高可用基础：主从复制是哨兵模式和集群模式能够运行的前提。</li>
</ol>
<h2 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a>工作原理</h2><p>Redis 的主从同步分为两个阶段：全量复制和增量复制。</p>
<h3 id="全量复制（首次连接）"><a href="#全量复制（首次连接）" class="headerlink" title="全量复制（首次连接）"></a>全量复制（首次连接）</h3><p>当一个从节点第一次连接主节点，或者断开时间太长导致数据无法衔接时，会发生全量复制：</p>
<ol>
<li>同步请求：从节点发送 psync 命令给主节点。</li>
<li>生成快照：主节点执行 bgsave 生成 RDB 文件，同时用一个缓冲区记录从现在开始的所有写命令。</li>
<li>发送 RDB：主节点将 RDB 文件发送给从节点。</li>
<li>加载数据：从节点清空旧数据，载入 RDB 文件。</li>
<li>同步缓冲区：主节点把刚才记录在缓冲区的写命令发给从节点，从节点执行这些命令，达到数据一致。</li>
</ol>
<h3 id="增量复制（网络闪断后）"><a href="#增量复制（网络闪断后）" class="headerlink" title="增量复制（网络闪断后）"></a>增量复制（网络闪断后）</h3><p>如果主从之间的网络连接断开了很短的时间，重新连接后不需要重新传整个<br>RDB，而是只传断开期间的数据，这里首要介绍一个Offset（偏移量），可以把它想象成一个循环队列，当新的数据量到达环的尾部的时候若此时还有新的数据进来后会覆盖掉最开始的数据，主从节点都会维护一个复制偏移量（一个循环队列）。主从之间会定时发送心跳（默认<br>1s 一次），用于检测链路状态和汇报偏移量。</p>
<ul>
<li>如果心跳中汇报的 Replica Offset &lt; Master Offset，主节点就会从复制积压缓冲区（Replication Backlog<br>Buffer）中提取缺失的数据，重新发给从节点。</li>
<li>因为Offset是一个环形数组，如果偏移量已经不在了（被覆盖了），则被迫进行全量同步。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>心跳检测：主从之间会定时发送心跳（默认 1s 一次），用于检测链路状态和汇报偏移量。</li>
<li>异步复制：主节点处理完写命令后直接给客户端返回成功，然后异步地将命令发给从节点。这意味着主从之间存在微小的数据延迟。</li>
<li>从节点只读：默认情况下，从节点是只读，这能防止数据被意外修改导致主从不一致。</li>
</ol>
<h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><h2 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h2><p>在简单的主从架构中，如果主节点（Master）宕机，必须人工手动将从节点（Slave）提升为主节点，并通知所有应用修改地址。而哨兵机制就是实现这一过程的自动化管家。哨兵是一个特殊的<br>Redis 服务，它不存储数据，而是作为一个独立的进程运行，主要负责三件事：</p>
<ul>
<li>监控（Monitoring）：哨兵会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li>通知（Notification）：当被监视的某个 Redis 服务器出现问题时，哨兵可以通过 API 向管理员或其他应用程序发送通知。</li>
<li>自动故障转移（Automatic Failover）：如果主节点挂了，哨兵会从剩下的从节点中选出一个新的主节点，并让其他从节点改为从属于新主。</li>
</ul>
<p>哨兵判断主节点是否下线：</p>
<ol>
<li>主观下线： 单个哨兵发现主节点在指定时间内没有响应（心跳检测超时），它认为这个节点“主观上”挂了。</li>
<li>客观下线： 当大多数哨兵（达到配置的 quorum 数量，quorum值一般是超过Sentinel实例数量的一半）都认为该主节点已经挂了，那么这个节点就被判定为“客观下线”。此时，故障转移流程正式启动。</li>
</ol>
<h2 id="工作原理-4"><a href="#工作原理-4" class="headerlink" title="工作原理"></a>工作原理</h2><p>当确认主节点“客观下线”后，哨兵们会进行如下操作：</p>
<h3 id="选举leader："><a href="#选举leader：" class="headerlink" title="选举leader："></a>选举leader：</h3><p>Sentinel集群要选出一个执行failover的Sentinel节点，所以必须要选出由哪个sentinel来执行。要成为leader要满足两个条件：</p>
<ul>
<li>最先获得超过半数的投票（Sentinel节点的数量一般设置为<span style="color:red;">奇数</span>，最小从3开始）</li>
<li>获得的投票数不小于quorum值</li>
</ul>
<p>而sentinel投票的原则有两条：</p>
<ul>
<li>优先投票给目前得票最多的</li>
<li>如果目前没有任何节点的票，就投给自己</li>
</ul>
<p>例：有3个sentinel节点，s1、s2、s3，假如s2先投票：</p>
<ol>
<li>此时发现没有任何人在投票，那就投给自己。s2得1票</li>
<li>接着s1和s3开始投票，发现目前s2票最多，于是也投给s2，s2得3票</li>
<li>s2称为leader，开始故障转移</li>
</ol>
<p>所以，通常来说第一个确认master客观下线的人会立刻发起投票，一定会成为leader。但是有极端情况下可能会出现s1,s2,s3都投了自己怎么办，此时会宣告此轮投票失败，所有哨兵会等待一段随机的时间，然后进入下一个纪元（Epoch）重新开始选举。由于等待时间是随机的，下一轮继续按照上述规则进行投票直到选出leader。</p>
<h3 id="选取新的master"><a href="#选取新的master" class="headerlink" title="选取新的master"></a>选取新的master</h3><p>新的master会从剩下的slave中选取，选取规则如下：</p>
<ol>
<li>首先会判断slave节点与master节点断开时间长短，如果超过指定值则会排除该slave节点</li>
<li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li>
<li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li>
<li>最后是判断slave节点的运行id大小，越小优先级越高。</li>
</ol>
<h3 id="更换主节点"><a href="#更换主节点" class="headerlink" title="更换主节点"></a>更换主节点</h3><p>此时选择出来的leader会按照下面顺序来重新执行master：</p>
<ol>
<li>选出一个 Slave，发送 SLAVE OF NO ONE 让它称为主节点。</li>
<li>通知其他 Slave 连接新的master。</li>
<li>发布配置更新，让所有哨兵和客户端知道主节点换人了。</li>
</ol>
<h1 id="Redis分片集群"><a href="#Redis分片集群" class="headerlink" title="Redis分片集群"></a>Redis分片集群</h1><h2 id="简介-12"><a href="#简介-12" class="headerlink" title="简介"></a>简介</h2><p>当数据量突破单机物理内存限制（如超过 64GB），或者写操作并发极高单机 Master 无法抗住时，分片集群就派上用场了。<br>如果说“哨兵”是为了高可用，那么“集群”就是为了横向扩展。分片集群采用去中心化的设计，集群中的每个节点都是平等的，彼此通过<br>Gossip 协议 交换状态信息。此时数据不再存在一个节点上，而是分布在多个节点上。客户端可以连接集群中的任意一个节点来访问数据。</p>
<h2 id="工作原理-5"><a href="#工作原理-5" class="headerlink" title="工作原理"></a>工作原理</h2><p>分片集群中数据的分布机制是通过哈希槽。它没有使用简单的 hash(key) %<br>N，因为节点增减会导致数据大规模迁移。redis中固定是有16384个哈希槽，每个物理节点负责管理一部分槽位，例：</p>
<ul>
<li>节点 A 负责：0 - 5460</li>
<li>节点 B 负责：5461 - 10922</li>
<li>节点 C 负责：10923 - 16383</li>
</ul>
<p>当需要查询某一个值的时候，先对key进行CRC16 校验，得到一个整数。随后将该值对 16384 取模：$slot &#x3D; CRC16(key) \pmod{16384}$<br>。此时得到的就是插槽的位置。当节点数增加的时候只会影响每个节点所含有的哈希槽的数量并不会影响该值的存储位置。</p>
<h2 id="集群的高可用"><a href="#集群的高可用" class="headerlink" title="集群的高可用"></a>集群的高可用</h2><p>Redis Cluster 内部包含了哨兵的功能。每个“分片”通常由一个主节点和若干个从节点组成。可以看下图更为直观。<br><img src="/../../img/study/redis_1.jpeg"><br>节点之间互相发送 Ping 包，如果超过半数节点认为某个 Master 挂了，该分片就会触发故障转移。此时改master下会选取一个slave称为新的master并参与到集群中。</p>
<h2 id="客户端跳转机制-MOVED-重定向"><a href="#客户端跳转机制-MOVED-重定向" class="headerlink" title="客户端跳转机制 (MOVED 重定向)"></a>客户端跳转机制 (MOVED 重定向)</h2><p>由于数据分布在不同节点，客户端访问一个 Key 时，如果该 Key 不在当前连接的节点上就会按照下面顺序跳转：</p>
<ol>
<li>客户端发送命令给节点 A。</li>
<li>节点 A 计算发现该 Key 属于节点 B 负责的槽位。</li>
<li>节点 A 返回一个 MOVED 错误（包含节点 B 的 IP 和端口）。</li>
<li>客户端收到后，自动重定向并连接节点 B 完成请求。</li>
</ol>
<p>为了防止二次跳转，在某些编程语言中会引入Smart Client（在启动时或运行中，通过 CLUSTER SLOTS 命令获取整个集群的槽位分布图。） 像 Java 的 Jedis 或 Lettuce 这种客户端，会在本地缓存槽位映射表（通常是一个数组，长度为 16384，其中的值为指向节点的内存地址），直接计算出应该请求哪个节点，避免二次跳转。具体流程如下：</p>
<ol>
<li>缓存路由表：客户端连接集群后，会自动拉取并维护一份本地缓存，记录：Slot 0-5460 -&gt; Node A, Slot 5461-10922 -&gt; Node B 等。</li>
<li>本地计算：当你执行 SET mykey “hello” 时，客户端在发送请求前，先在本地通过 CRC16(“mykey”) % 16384 算出槽位（假设是 6000）。</li>
<li>精准打击：查询本地路由表发现 6000 属于 Node B，于是直接建立连接发送给 Node B。整个过程只需一次网络 IO。</li>
<li>动态更新（故障自愈）：如果集群发生了扩容、缩容或主从切换，导致槽位迁移，原有的缓存就会失效。此时客户端发送请求，Redis 节点会返回 MOVED。Smart Client 收到 MOVED 后，不仅会去请求新节点，<strong>还会自动异步更新本地路由表</strong>，确保下次请求依然精准。</li>
</ol>
<h1 id="Redis多线程"><a href="#Redis多线程" class="headerlink" title="Redis多线程"></a>Redis多线程</h1><p>随着网络硬件的发展（比如万兆网卡），Redis 的性能瓶颈不再是 CPU 或内存，而是网络 IO 的读写。大量的时间消耗在了“从网卡读数据”和“往网卡写数据”这两个动作上。为了解决这个问题 Redis 6.0 引入了 I&#x2F;O 多线程。</p>
<ul>
<li>主线程：依然负责最重要的 “命令执行”（计算逻辑）。</li>
<li>I&#x2F;O 线程：负责 “读写网络数据” 和 “协议解析”。</li>
</ul>
<p>Redis 的 数据读写逻辑（命令执行）依然是单线程的（保证了原子性和无需加锁），但网络数据的收发变成了多线程。如果命令执行变成多线程，Redis 就必须引入 “锁”（Lock）机制来保证数据安全。而加锁和释放锁都是巨大的性能开销，而且还可能会产生死锁问题，除此之外，多线程切换带来的上下文切换损耗，在内存操作这种极快的情况下，反而可能比单线程更慢。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a><a class="post-meta__tags" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></div><div class="post-share"><div class="social-share" data-image="/../../img/study/redis_0.jpeg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2026/01/19/error/Seata%E9%85%8D%E7%BD%AE%E4%BC%A0%E9%80%92%E5%A4%B1%E8%B4%A5/" title="Seata配置传递失败"><img class="cover" src="/../../img/error/seata.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Seata配置传递失败</div></div><div class="info-2"><div class="info-item-1">问题背景微服务中有两个模块，common和cart模块，此时我想要给cart模块做分布式事务，所以要引入seata，因为考虑到可能其他模块也会用到分布式事务，所以我将该依赖直接引入到common中，依赖如下。 12345&lt;!--seata--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;&lt;/dependency&gt;  引入后启动cart服务，报了如下错误。 111:13:19:906 ERROR 20948 --- [eoutChecker_1_1] i.s.c.r.netty.NettyClientChannelManager  : can not get cluster name in registry config &#x27;service.vgroupMapping.default_tx_group&#x2...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">EnyooXu</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">2.1.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">2.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash"><span class="toc-number">2.2.</span> <span class="toc-text">Hash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">2.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-1"><span class="toc-number">2.2.3.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.4.</span> <span class="toc-text">存储原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">2.3.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="toc-number">2.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-2"><span class="toc-number">2.3.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-2"><span class="toc-number">2.3.3.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-number">2.4.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="toc-number">2.4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-3"><span class="toc-number">2.4.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-3"><span class="toc-number">2.4.3.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86-1"><span class="toc-number">2.4.4.</span> <span class="toc-text">存储原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZSet"><span class="toc-number">2.5.</span> <span class="toc-text">ZSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="toc-number">2.5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-4"><span class="toc-number">2.5.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-4"><span class="toc-number">2.5.3.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GEO"><span class="toc-number">2.6.</span> <span class="toc-text">GEO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-5"><span class="toc-number">2.6.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-5"><span class="toc-number">2.6.2.</span> <span class="toc-text">应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">3.</span> <span class="toc-text">通用指令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">Redis问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">4.1.</span> <span class="toc-text">缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-6"><span class="toc-number">4.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.2.</span> <span class="toc-text">解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E9%87%8F-Key-%E5%90%8C%E6%97%B6%E8%BF%87%E6%9C%9F"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">大量 Key 同时过期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%AE%95%E6%9C%BA-%E4%B8%8D%E5%8F%AF%E7%94%A8"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">Redis 宕机&#x2F;不可用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E7%BA%A7%E7%9A%84%E4%BF%9D%E6%8A%A4"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">数据库层级的保护</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">4.2.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-7"><span class="toc-number">4.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-1"><span class="toc-number">4.2.2.</span> <span class="toc-text">解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81-redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">互斥锁(redis分布式锁)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">逻辑过期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">其他方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">4.3.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-8"><span class="toc-number">4.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-2"><span class="toc-number">4.3.2.</span> <span class="toc-text">解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">缓存空对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">布隆过滤器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95-1"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">其他方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">Redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-9"><span class="toc-number">5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">持久化方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB"><span class="toc-number">5.2.1.</span> <span class="toc-text">RDB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF"><span class="toc-number">5.2.2.</span> <span class="toc-text">AOF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E7%AD%96%E7%95%A5"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">保存策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">重写机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">5.2.2.4.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%88RDB-AOF%EF%BC%89"><span class="toc-number">5.2.3.</span> <span class="toc-text">混合模式（RDB + AOF）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-2"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">工作原理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E4%B8%BB%E4%BB%8E"><span class="toc-number">6.</span> <span class="toc-text">Redis主从</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-10"><span class="toc-number">6.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-3"><span class="toc-number">6.2.</span> <span class="toc-text">工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6%EF%BC%88%E9%A6%96%E6%AC%A1%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="toc-number">6.2.1.</span> <span class="toc-text">全量复制（首次连接）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6%EF%BC%88%E7%BD%91%E7%BB%9C%E9%97%AA%E6%96%AD%E5%90%8E%EF%BC%89"><span class="toc-number">6.2.2.</span> <span class="toc-text">增量复制（网络闪断后）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">6.3.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">哨兵模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-11"><span class="toc-number">7.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-4"><span class="toc-number">7.2.</span> <span class="toc-text">工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E4%B8%BEleader%EF%BC%9A"><span class="toc-number">7.2.1.</span> <span class="toc-text">选举leader：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E5%8F%96%E6%96%B0%E7%9A%84master"><span class="toc-number">7.2.2.</span> <span class="toc-text">选取新的master</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%8D%A2%E4%B8%BB%E8%8A%82%E7%82%B9"><span class="toc-number">7.2.3.</span> <span class="toc-text">更换主节点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">8.</span> <span class="toc-text">Redis分片集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-12"><span class="toc-number">8.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-5"><span class="toc-number">8.2.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">8.3.</span> <span class="toc-text">集群的高可用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B7%B3%E8%BD%AC%E6%9C%BA%E5%88%B6-MOVED-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">8.4.</span> <span class="toc-text">客户端跳转机制 (MOVED 重定向)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">9.</span> <span class="toc-text">Redis多线程</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent;"><div class="footer-other"><div class="footer-copyright"></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4-b1"></script><script src="/js/main.js?v=5.5.4-b1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: [''],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '6ce1d8c967a1c32a6154486261c1a6a7'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4-b1"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_categories_card_injector_config(){
    // 检查容器是否存在
    var parent_div_git = document.getElementById('recent-posts');
    // 如果容器不存在，则动态创建
    if (!parent_div_git) {
      console.warn('butterfly_categories_card: 挂载容器不存在，正在动态创建...');
      // 创建新容器（默认插入到页面主体顶部）
      parent_div_git = document.createElement('div');
      parent_div_git.id = 'recent-posts'; // 赋予配置的ID
      document.querySelector('#page').prepend(parent_div_git); // 插入到 #content-inner 内
    }
    var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 570px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 480px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(/img/categories/error.png);"><a class="categoryBar-list-link" href="/categories/错误汇总/">错误汇总</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(/img/categories/idea.png);"><a class="categoryBar-list-link" href="/categories/IDEA配置/">IDEA配置</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(/img/categories/study.png);"><a class="categoryBar-list-link" href="/categories/学习/">学习</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
    console.log('已挂载 butterfly_categories_card');
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
  }
  // 路径匹配逻辑（使用 startsWith）
  if (location.pathname.startsWith('/categories/') || '/categories/' === 'all') {
    butterfly_categories_card_injector_config();
  }
  </script><!-- hexo injector body_end end --></body></html>